//متود این است که یک فانکشن را به یک تایپ اَتَچ کنیم و در قسمت «ریسیور» فانکشن، آن تایپ را بهمراه یک متغیر بنویسیم.
//به آن فانکشن که به یک تایپ اتچ شده «متود» گفته میشه.
//func (r receiver) identifier(parameters) (return(s)) { code }
package main

import (
	"fmt"
)

type person struct {
	first string
	last  string
}

type secretAgent struct {
	person
	ltk bool
}

//اینجا یک فانکشن ساخت که در قسمت ریسیور یا همان دریافت کننده ی آن، تایپِ سیکرت اِیجنت را با متغیر اِس قرار داد،
//وقتی فانکشن «اسپیک» را به تایپ «سیکرت ایجنت» اَتَچ کرد (چسباند)
//آنگاه فانکشن «اسپیک» به همه ی ولیو های «سیکرت ایجنت» به وسیله ی یک نقطه (.) دسترسی پیدا میکند
func (s secretAgent) speak() {
	fmt.Println("I am", s.first, s.last)
}

func main() {
	sa1 := secretAgent{
		person: person{
			"James",
			"Bond",
		},
		ltk: true,
	}

	sa2 := secretAgent{
		person: person{
			"Miss",
			"Moneypenny",
		},
		ltk: true,
	}

	fmt.Println(sa1)
	//این عبارت در واقع کال کردن است منتها کال کردن یک فانکشن که به یک تایپِ استراکت اتچ شده است.
	//ساختار نوشتاری و اون نقطه ای که اون وسط هست خیلی مهمه، که یعنی هر وقت struct داشتی و خواستی به زیر مقادیر دسترسی پیدا کنی
	//باید اول متغیر بیرونی تر رو بنویسی بعد نقطه و بعد آن متغیر درونی تر رو بنویسی که میتونه یه فانکشن باشه.
	//پس در اینجا متغیرِ تایپِ استراکت ، بیرونی تر هست و فانکشن اسپیک درونی تر هست چون به تایپِ استراکت اتچ شده.
	//پس همیشه درونی به بیرونی اتچ میشه. و معنای اتچ همین هست اصلن.
	sa1.speak()
	sa2.speak()
}
